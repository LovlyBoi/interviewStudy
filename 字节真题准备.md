# 字节2022 1 - 4月真题实战

1. 手写Promise.all方法
    ```js
    Promise.myAll = function (promises) {
        return new Promise((resolve, reject) => {
            // 1. 首先这个参数promises他不一定非要是一个数组, 而是只要是可迭代对象都ok的
            // 所以先判断他是不是可迭代对象
            if (typeof promises[Symbol.iterator] !== "function") {
                throw new TypeError("first argument must be an iterator");
            }
            let finishedCount = 0;
            let taskCount = 0;
            const result = [];
            for (let promiseTask of promises) {
                let currentIndex = taskCount;
                taskCount++;
                Promise.resolve(promiseTask).then(data => {
                    result[currentIndex] = data;
                    finishedCount++;
                    if (finishedCount >= taskCount) {
                        // 代表处理完了
                        resolve(result);
                    }
                }).catch(reason => reject(reason))
            }
        })
    }
    
    // 测试
    const pro1 = new Promise((resolve) => {
        setTimeout(() => {
            resolve(1);
        }, 2000)
    })
    
    const pro2 = Promise.resolve(2);
    
    const pro3 = Promise.resolve(3);
    
    Promise.myAll([pro1, pro2, pro3, Promise.reject("err")]).then(data => {
        console.log("data", data);
    }).catch(reason => {
        console.log("reason", reason);
    })
    ```

2. 说说可以遍历object.value的方法?
    - for...in: 但是for...in会遍历到原型链上的成员, 需要使用hasOwnProperty进行隔离
    - Object.getOwnPropertyNames: 会得到对象所有自身的key值, 然后去遍历这个key值就好了
    - Object.entries: 得到对象所有key + value的数组


3. 使用css分别绘制等腰三角形, 直角三角形
    ```html
    <div class="triangle"></div>
    ```
    如果是绘制直角三角形, 那我们让上右border的变为transparent即可
    ```css
    .triangle {
        width: 0px;
        height: 0px;
        border: 100px solid #ddd;
        border-top-color: transparent;
        border-right-color: transparent;
    }
    ```
    如果是绘制等腰三角形, 我们只需要显示上下左右的一个边框色, 其他色均为transparent即可
    ```css
    .triangle {
        width: 0px;
        height: 0px;
        border: 100px solid #ddd;
        border-top-color: transparent;
        border-right-color: transparent;
        border-left-color: transparent;
    }
    ```

4. JS原型链解释:
    原型是function对象上的一个属性, 它表示构造函数构造出来的对象的共有祖先, 被通过构造函数构造出来的对象上有一个```__proto__```属性指向该函数的prototype, prototype本身也是一个对象, 所以这种__proto__与prototype之间的连接关系会变成一个链条, 这就是原型链, 通过原型链我们可以提取共有属性, 并实现继承

5. JS实现一个继承:
    ```js
    function inherit(Origin, Target) {
        function F() {}
        F.prototype = Origin.Prototype;
        const f = new F();
        Target.prototype = f;
        Target.prototype.constructor = Target;
        Target.prototype.superFather = Origin;
    }
    ```

6. 数据结构有哪些, 每种的特点, 给数组结构分类的方法
    常见的数据结构及其特点如下:
    - 栈: 栈结构最大的特点就是先进后出
    - 队列: 队列最大的特点就是先进先出
    - 链表: 
        - 链表在物理地址上可以是不连续的, 所以只要内存足够大, 就一定存的下, 不用担心空间碎片的问题, 但是因为地址是不连续的, 所以查询性能不太好
        - 没存放一个值都得多开销一个引用空间
    - 树: 树是图的一种, 但是树是没有回路的, 他的学名叫做有向无环图
    - 图:
    - 数组: 
        - 数组定长, 就算是在前端JS里好像是不定长的, 但是实际上在底层他也是定长的, 不过是JS引擎帮我们完成了数组扩容的过程, 数组扩容是比较消耗性能的(就是比如你之前是9个成员的数组, 你给推进去一个新成员, 这时候底层会向操作系统重新开一个18长度的地址, 然后将之前的9个成员挨个复制, 然后再把第10个给放进去)
        - 存储在物理空间上是连续的, 所以当操作系统空间碎片较多且数组较大的时候, 容易存不下
        - 数组的变量指向了数组的第一个元素的位置, 我们使用下标去访问数组实际上在底层里是在进行存储地址的偏移, 因为是偏移, 所以数组的查询性能好

    给数据结构分类可以根据逻辑类型去分类就可以分为线性结构和非线性结构, 然后也可以通过顺序结构去分类, 比如顺序存储和链式存储, 还可以通过运算方式分类好像, 不过这里没复习到, 具体的分类流程不太记得了

7. 给定一个二叉树与一个值，找到和为该值的二叉树的所有路径(算法
    ```js
    function pathSum(root, target) {
        if (!root) return [];
        const result = [];
        function calcRoot(node, sum, path) {
            if (!node) return;
            sum += node.value;
            path.push(node.value);
            if (node.left == null && node.right == null && target === sum) {
                result.push(path.slice());
            }
            // 递归加载左右子树
            calcRoot(node.left, sum, path);
            calcRoot(node.right, sum, path);
            // 清空一下栈
            path.pop();
            sum -= node.value;
        }
        return result;
    }
    ```

8. 数组去重
    这里写几个比较经典的去重方法:
    - ES6的set去重
        ```js
        const arr = [1, 3, 2, 5, 2, 3, 4, 5];
        function unique(arr) {
            return new Set(arr);
        }
        const uniqueArr = unique(arr);
        console.log("uniqueArr", uniqueArr);
        ```
    - 使用object来进行去重
        ```js
        const arr = [1, 3, 2, 5, 2, 3, 4, 5];
        function unique(arr) {
            const result = [];
            for (let i = 0, len = arr.length; i < len; i++) {
               if (result.indexOf(arr[i]) === -1) {
                   result.push(arr[i]);
               }
            }
            return result;
        }
        ```
    - 利用arr.sort来去重
        ```js
        const arr = [1, 3, 2, 5, 2, 3, 4, 5];
        function unique(arr) {
            const _arr = JSON.parse(JSON.stringify(arr)).sort((a, b) => a - b);
            let compareValue = null;
            const result = [];
            for (let i = 0, len = _arr.length; i < len; i++) {
               if (!i || compareValue !== arr[i]) {
                   // 如果不是第一个元素或者compareValue和当前的arr不相等, 则可以push
                   result.push(arr[i]);
                   compareValue = arr[i];
               }
            }
            return result; 
        }
        ```

9. 输入url到显示的全过程:
    - 浏览器接受到url然后进行域名解析(先到本地的host文件里找有没有对应上的域名, 如果没有则提交给最近的dns服务器进行域名解析)
    - 得到域名对应服务器以后先进行TCP3次握手
        - 第一次握手: 由浏览器发起, 告知服务器我要发送请求了
        - 第二次握手: 由服务器发起, 告知浏览器我准备好接受请求了
        - 第三次握手: 由浏览器发起, 告知服务器我马上就要发了, 你准备好接受吧
        > 至于为什么要3次握手而不是两次就行了的主要原因就是为了防止已经失效的请求报文到达服务器的时候, 服务器依然选择响应, 比如说某个请求报文在一个传输节点上卡了非常久, 客户端自己都放弃了, 但是很久以后他又传送到服务器了, 这时候服务器会不知道他是已经失效的, 所以会立马响应, 这是没有必要的
    - 然后向域名对应的服务器发送资源请求, 服务器接收到请求以后响应给客户端对应的网页资源
    - 浏览器接受到网页资源开始解析html文档, 生成dom树
    - 浏览器解析css文档生成cssom树
    - 浏览器将dom树和cssom树进行合并生成渲染树
    - 浏览器开始进行布局(这个过程又叫做重排), 还有重绘
    - 页面展示对应内容给到用户
    - 另外在http的各个节点中, 会进行四次挥手来断开连接:
        - 第一次挥手: 由浏览器发起的, 我请求报文发送完了, 你准备好关闭吧
        - 第二次挥手: 由服务器发起的, 告诉浏览器, 我请求报文也接收完了, 我准备关闭了
        - 第三次挥手: 由服务器发起的, 告诉浏览器, 我响应报文也发送完了, 你可以关闭了 
        - 第四次挥手: 由浏览器发起的, 告诉服务器, 我响应报文也收完了, 咱们拜拜吧

10. 解释一下什么是宏任务, 什么是微任务?
    首先无论是在node还是在浏览器端JS引擎都会有一个事件循环系统, 当遇到一个异步任务的时候, JS引擎会将其交给对应环境的调度线程去处理, 当调度线程处理完毕以后会将注册的对应回调送进任务队列, JS主线程执行完毕以后会去看队列里有没有需要执行的任务, 有的话就拉出来执行一下, 然后这个队列分为宏任务和微任务, 像setTimeout, setInterval会进入宏任务, process.nextTick, Promise, MutationObserver会进入微任务, 在查看队列并执行的时候, JS引擎会优先看微任务有没有等待的任务, 微任务执行完毕以后才会看宏任务

11. js的数据类型有哪些, 为什么存在栈和堆
     js目前我知道的数据类型有: number, string, boolean, object, undefined, symbol, bigInt, 基础数据类型像number, string, boolean, undefined都会直接存入栈中, 然后引用数据类型比如object就会直接放入堆中, 我觉得堆和栈存在的意义就是更好的去管理内存？ 因为我记得栈里的东西是用完就没了比较好垃圾回收, 堆里面的东西必须要完全没有任何变量引用他的时候才会被垃圾回收, 方便区分管理

12. css元素居中
     这种情况分为知道自己宽高的和不知道自己宽高的:
     - 知道自己宽高的: 父级relative定位, 需要居中的元素absolute定位， 并设置left: calc(50% - 自身宽度的一半), top: calc(50% - 自身宽度的一半)
     - 不知道自己宽高的: 父级relative定位, 需要居中的元素absolute定位, 并设置left: 50%, top: 50%, 然后使用transform的translate将x轴和y轴各-50%
     - 另外就是一个比较通用的, 使用flex布局: 父级设置display: flex, justify-items: center; align-items: center;

13. 阐述一下闭包
     民间有一种比较通俗的说法是内部函数被保存到了外部就会产生闭包, 但是我看mdn上有一个比较官方的解释是: 只要访问了自身作用域以外的作用域, 就会产生闭包, 闭包会导致原有作用域不被释放, 造成内存泄露, 当然 我们也可以合理使用闭包来达到留存状态的目的

14. 引用值类型和原始值类型的区别？
     引用值放在堆内存, 原始值放在栈内存, 原始值的复制实际上是在复制副本, 而引用值的复制实际上是在复制地址

15. vue的响应式原理
     vue的响应时原理主要围绕vue的四个小玩具来进行的:
     - Observer: 这个构造类主要是用来给数据设置上getter和setter, 设置上getter和setter以后vue就有机会在读取值是设置值的时候做一些事情, 在vue2中Observer主要使用了Object.defineProperty来进行代理操作, 但是这样有一些缺点, 一个就是性能损耗会比较大, 因为他是深度递归data中的每一个数据, 并设置上getter和setter, 当数据量过大的时候, 自然性能就没那么好, 不过vue2也没办法, 另一个问题就是使用Object.defineProperty设置的代理没法追踪到成员的新增和删除, 所以vue提供了$set和$delete方法来弥补这个缺陷, 然后到了vue3以后, vue使用了Proxy来进行代理, 由于Proxy的代理类似于事件委托是一个动态的机制, 所以之前的两个问题都得到了完美的解决, 所以vue3里我们也可以看到$set和$delete方法已经被移除了
     - Dep: 上面我们说到Observer就是设置了getter和setter, 那么Dep就是在getter和setter中要做的事情**收集依赖**和**通知变更**, 我没记错的话, 在getter中vue会调用Dep.depends方法去收集依赖（比如说, 某个组件的render方法访问了这个数据, 那么这个组件就应该要被收集进依赖里）,在setter中, vue会调用Dep.notify方法去发布通知, 告诉每一个依赖了该数据的人我变了, 你要重新计算了
     - Watcher: 上面我们说道Dep他主要就是收集依赖和发布通知的, 那么他收集依赖的时候怎么知道收集谁作为依赖呢？ 所以这里就来了一个Watcher, 他收集的依赖收集的不是别的东西收集的就是Watcher, 在每个组件的上下文环境里都有一个对应的Watcher, 当发布通知的时候, 通知的也是Watcher, Watcher上会有render等方法, 所以当变更的时候调用对应的方法
     - Scheduler: 调度器, 我们知道, 每一次setter的赋值都会导致对应Watcher去调用对应的render方法, 这显然是不合理的, 所以调度器就来了, 当需要变更时Watcher会把自己交给Scheduler, 调度器会将Watcher推入微队列进行合并更新, 最终导致页面重新渲染
     这就是整个Vue的响应式原理

16. 聊聊跨域
     浏览器有一个同源策略, 如果不是同协议, 同域名, 同端口就没法进行资源的共享和引用, 我们要越开这个限制就叫做跨域, 跨域的手段有如下:
     - jsonp: 利用的是script标签src不受同源策略影响的机制, 比较古老了
     - cors: 全称cross origin resource sharing, 意为跨域资源共享, 这个是后端在响应头里追加Access-Control-Allow-Origin字段来控制浏览器进行跨域, 这个字段的值可以是指定的域名也可以是*, *代表任意域名都ok 当然配合Access-Control-Allow-Origin的还有一些字段, 比如Access-Control-Allow-Credentials是一个布尔值意为是否允许跨域携带cookie
     - 在开发阶段, 我们可以配置webpack的devServer进行跨域, 这个原理主要是webpack会开启一个koa的本地localhost服务器, 因为服务端不会受到同源策略的影响, 他用koa服务器请求了资源在转接给客户端
     - Nginx配置跨域, 本质上和cors没啥区别
     - 还有一些比较冷门的, location +_ iframe跨域, document.domain + iframe跨域的以前有了解过, 不过具体流程这下回忆不上来了

17. get和post
     在真正的网络底层post和get是没有区分的, 但是按照我们现在的交互标准, 将get和post做了一些区分如下:
     - get的参数放在url中, 而post放在request body中, 所以有的人会说post比get稍微安全一点
     - get发出去的请求只会有urlencoded格式, 而post可以有多种格式比如application/json, urlencoded等
     - get由于浏览器对url有长度限制, 所以get请求的参数也是有长度限制的, 而post没有
     - get请求可以被缓存, post不行

18. 说一下http缓存
     http缓存分为强缓存和协商缓存:
     - 强缓存: 如果服务端在响应头中设置了expire或者cache-control字段, 浏览器会将响应结果进行缓存 当再次尝试请求时, 会命中强缓存, 如果该资源的强缓存时长没有过期, 则不会向服务端发送请求, 转而直接使用缓存
         - expire: 一个绝对时间, gmt的字符串, 只要当前浏览器时间没有超过这个时间, 则代表强缓存没有过期, 但是由于时区的差异, expire字段可能会发生一些意外情况
         - cache-control: cache-control字段是一个相对时间, 比如3600毫秒, 他弥补了expire的缺陷, 因为你始终只需要在浏览器时间的基础上加上这个相对时间即可
     - 协商缓存: 如果服务端在响应头里设置了last-modified或者etag字段, 浏览器会在下一次请求时先发送一个请求(会带上if-modified-since和if-none-match字段)给服务器来确定是否需要重新请求资源, 如果服务器说不需要则直接使用缓存, 需要的话就会重新请求, 那么协商缓存的这两个字段的含义如下:
         - last-modified: 文件的上次变动时间, 这个会有点缺陷就是有时候服务端并不是文件内容变了导致的文件变动, 但是客户端用这个文件变动时间的话可能会导致无意义的重新请求
         - etag: 所以etag字段就是用来解决last-modified的缺陷的, 他是一个算法, 由服务器和客户端进行协商, 如果文件内容没有变, 则etag的值不会变化

     另外f5刷新的话Chrome Safari不会导致缓存失效, 但是强制刷新ctrl+f5的话会导致缓存全部失效

19. 原型链
     原型是function对象上的一个属性, 叫做prototype, 他定义了构造函数构造出来的对象的公有祖先, 每个对象上都有一个__proto__属性指向自己构造函数的prototype, 这种对象与构造函数之间不断的链接关系就叫做原型链, 大部分情况下, 所有对象的原型层层递进最终都会指向Object.prototype, 通过Object.create(null)得到的对象并不会拥有原型, 箭头函数也没有自己的prototype, 通过原型我们可以实现继承关系, 达到提取公有成员的目的

20. 线程和进程
     - 进程: 进程是对运行时程序的封装, 是操作系统调度和分配的, 实现了操作系统的并发
     - 线程: 线程是进程的子任务, 是cpu调度和分配的, 实现了进程内部的并发
     一个线程是能属于一个进程, 一个进程可以拥有多个线程, 多个线程会共享进程的内存, 这是我理解的, 然后一些比较深入的有看过, 但是这下想不太起来了

21. 为什么在js中0.1 + 0.2 不等于0.3?
     我的理解是计算机底层的计算基础是基于二进制的, 所以他需要先将十进制的0.1和0.2都转换成二进制, 在这个转换过程中, 0.1和0.2好像是会无限循环, 然后js采用的是IEEE 754标准所以他会进行舍弃操作, 所以自然就会丢失掉了一些精度, 所以最后就不等于0.3了, 要解决这个问题的话 可以将其转换为整数进行相加 也可以使用第三方库比如bigNumber或者Math.js

22. 写一个继承
     ```js
     function inherit(Origin, Target) {
         function F() {}
         F.prototype = Origin.prototype;
         Target.prototype = new F();
         Target.prototype.constructor = Target;
         Target.prototype.superFather = Origin;
     }
     ```

23. flex布局有了解过吗？
     我们只要给父元素设置display: flex就能够让整个父元素变成flex容器, 同时该容器内的直接子元素都会变成flex元素, flex容器有两根轴线,这两根轴线决定了flex元素的排列位置, flex容器上可以设置的属性有:
     - flex-direction: 决定了主轴的方向, 默认情况下水平方向的是主轴, 垂直方向的是交叉轴
     - flex-wrap: 决定flex元素是否允许换行
     - justify-content: 决定了flex元素在主轴上的排列方式, 取值有space-around, space-between, flex-start, flex-end, center等
     - align-items: 决定了当前flex元素的交叉轴排列方式, 取值有baseline, flex-start等, 默认值是stretch
     - align-content: 当设置了flex-wrap导致flex元素换行以后会产生多条交叉轴线, 该属性决定了多条交叉轴线的时候flex元素的排列位置
     在flex元素上也存在一些属性可以配置:
     - order: 决定了该flex元素的排列顺序, 不管你的真实dom排序是怎样的, order属性值越小, 该flex元素排列越靠前
     - flex-grow: 决定了该flex元素在flex容器还有剩余空间的时候是否拉伸 默认为0 表示不允许拉伸, 为1表是允许拉伸
     - flex-shrink: 决定了该flex元素在flex容器没有多余空间分布的时候是否压缩, 默认为1表示允许压缩, 为0表示不允许压缩
     - flex-basis: 决定了该flex元素在flex容器中占据的位置, flex容器会根据这个值去判定剩余的空间, 如果要设置的话最好设置为和宽度一样
     - flex: 为flex-grow, flex-shrink, flex-basis的符合属性

24. 如果我想要flex容器的内容等分我应该怎么办? 
     不设置flex元素的宽度, 将flex-grow设置为1

25. 浅谈一下bfc
     bfc, block formatting context, 块级格式化上下文, 他就是浏览器在布局的时候所用到的区域, 默认情况下html根元素会直接开启块级格式化上下文, 然后我们可以通过一些属性比如overflow-hidden, float等来开启新的bfc, bfc等同于一个独立的布局区域, 开启了bfc的元素中的子元素会按照流式去排列和计算高度, 所以我们可以通过开启bfc来解决一些问题: 比如float元素的清除浮动问题, 以及解决margin塌陷和margin重叠问题, 但是大部分的触发bfc是会有副作用的, 比如overflow可能会导致你的内容溢出隐藏 即便你不想这样, 所以目前有一个新的属性display: flow-root来无副作用的开启bfc

26. 说说 margin塌陷和margin重叠
     - margin重叠: 处于同一个bfc的两个box一个设置margin-bottom, 一个设置margin-top会产生margin重叠
         ```html
         <style>
             .content {
                 width: 100px;
                 height: 100px;
                 background: #ddd;
             }
             .content: first-of-type {
                 margin-bottom: 100px;
             }
             .content: last-of-type {
                 margin-top: 100px
             }
         </style>
         <body>
             <div class="content"></div>
             <div class="content"></div>
         </body>
         ```
         在上面这个例子里, 两个content上下之间间隔应该200px, 但是在浏览器中我们发现他们只间隔了100px, 这就是margin重叠, 处理这个我们只需要让其中一个content进入一个新的bfc环境中即可
         ```html
          <style>
             .new-bfc-block {
                 display: flow-root;
             }
             .content {
                 width: 100px;
                 height: 100px;
                 background: #ddd;
             }
             .content: first-of-type {
                 margin-bottom: 100px;
             }
             .content: last-of-type {
                 margin-top: 100px
             }
         </style>
         <body>
             <div class="content"></div>
             <div class="new-bfc-block">
                 <div class="content"></div>
             </div>
         </body>
         ```
     - margin塌陷: 父元素没有设置border, 也没有设置padding-top, 元素内容里还没有文字, 这三个条件同时满足的情况下就会产生margin塌陷, 此时他的子元素设置margin-top时, 父元素会跟着往下掉, 要解决这个问题, 我们可以触发父元素的bfc
         ```html
         <style>
             .main {
                 width: 200px;
                 height: 200px;
                 background: green;
             }
             .content {
                 width: 100px;
                 height: 100px;
                 margin-top: 100px;
             }
         </style>
         <body>
             <div class="main">
                 <div class="content"></div>
             </div>
         </body>
         ```
         解决方案如下
         ```css
         ...
         .main {
             width: 200px;
             height: 200px;
             background: green;
             <!-- 只要加下面一行代码就ok了 -->
             display: flow-root;
         }
         ...
         ```

27. 说说JS的单线程
     单线程就是同一时间只能做一件事, 所以JS在运行的永远是主线程, 至于很多异步任务, 他都是交给其他调度线程比如计时器, 网络去完成的, 但是目前html5提供了一个新的api web worker, 这个api允许我们JS变成多线程

28. 介绍一下回流与重绘
     浏览器因为元素的规模尺寸布局等变化造成renderTree重新构建的过程就叫做重排(回流), 页面初次加载的时候必定产生一次回流
     如下操作会造成浏览器的回流:
     - 页面首次渲染
     - 浏览器窗口大小发生改变
     - 元素几何尺寸或者位置信息发生了改变
     - 元素内容变化, 文字数量或者图片大小等
     - 元素字体大小变化
     - dom的新增和删除
     - 激活css伪类, 如hover
     - 查询某些属性（比如获取元素的动态几何属性）或者方法（比如scrollTo)
     重绘就是当元素的一些外观样式比如颜色背景变化导致重新将渲染树绘制到屏幕的过程, 重绘不会涉及任何布局的变化
     **重排必定引起重绘, 重绘不一定引起重排**, 使用虚拟dom离线操作dom可以减少重排重绘的过程, 同时使用requestAnimationFrame等新api也可以尽量避免不必要的重排和重绘

29. http是基于什么层的？
     传输层

30. 能说说tcp和udp的区别吗？
     tcp是一种传输层协议, 他允许数据包从一个位置发送到另一个位置, tcp是面向连接的协议, 是比较可靠的, 因为数据的接收方总是会给发送方提供一条关于数据包的确认消息, 要么肯定要么否定, 因此发送方总是知道数据包是否到达他的目的地, 或者是否需要重新发送, 而且tcp保证了数据到达的时序性和发送时是一致的
     udp是不可靠的传输协议, 类似于一种尽力而为的做法, udp协议下, 发送方不会等待数据包是否接受的信号, 而接收方也不会给发送方法是否收到包的信号, udp还不会保证数据的时序性, 相较于tcp, udp更简单更快, 但是也不靠谱, 而且udp也是不需要做连接的, 而tcp在传输之前需要先连接
     tcp被用于http, Https等场景中, 而udp多数用于视频通话 语音通话这类场景下

31. 说说进程, 线程是什么, 了解协程吗？
     - 进程: 进程是一种抽象的概念, 他是操作系统调度和分配资源的最小单位, 是运行时程序的封装和载体, 任何进程都可以和其他进程一起并发工作
     - 线程: 线程是进程的子任务, 他是由cpu来进行调度和分配的, 线程实现了进程内部的并发
     一个线程只属于一个进程, 一个进程可以拥有多个线程, 进程之间相互独立, 但是线程之间是共享进程数据的
     - 协程: 协程就是由程序员自己写的基于线程但是比线程更加轻量的存在, 线程的调度是系统进行的, 而协程的调度是开发者自己管理的, 一个线程可以拥有多个协程, 线程的频繁创建销毁可能会带来性能问题, 但是协程不会发生比较严重的性能问题

32. 说说你都了解哪些攻击方式, 怎么防范?
     - csrf: cross site request forgery: 跨站请求伪造, 这个主要是当用户进行了登陆操作以后, cookie会被保存到浏览器中, 然后浏览器对于cookie的发送默认情况下是只要同源就会携带cookie, 这时候攻击者就诱导用户点击一个垃圾网站, 在垃圾网站中向对应服务器发送请求, 比如用户登陆了支付宝, 然后在垃圾网站中直接像支付宝发送支付请求, 这个时候浏览器发现请求的是支付宝的服务器, 于是就把用户的cookie给他带上了, 这时候服务器就发现发过来的请求时有cookie的, 于是进行了支付操作, 后果可想而知, 防范措施如下: 
         - 处理好cookie的same-site属性, same-site属性选strict和lux中的任意一个都可以, strict就是完全拒绝第三方网页携带发送cookie, 而lux稍微宽松一点, 他允许发送get形式的请求携带cookie
         - 服务器去检查请求头里携带过来的Origin或者Referer属性, 这两个字段都会标记实际请求的源网站, 然后根据实际情况进行处理
     - xss: cross site script: 跨站脚本攻击, 我举个场景, 用户有个添加新书的操作, 这时候攻击者在填写书名的时候将书名写成一个script标签并引入自己的攻击js, 这时候保存提交进了服务器, 当别人去查看这本书的详情的时候, 那段脚本就会被触发, 那段脚本里可以做很多事情, 不仅发送请求还可以直接获得你的cookie, 所以非常危险, 防范模式如下:
         - 服务端对用户的输入进行转码或者脚本检测
         - 利用好csp, csp是一种保护机制, 通过配置响应头里的一个字段叫做Content-Security-Policy来配置, 有了这个配置以后他可以直接禁止第三方脚本的加载, 还可以进行一些csp风险的上报
         - 一般的话xss主要是为了获取cookie, 那么我们把cookie配置成httponly也可以减缓这个风险
     - 中间人攻击: 这个主要就是利用http的缺陷, 拦截你的公钥然后进行第三方的数据窃取和监听, 有了https以后就不会有这个风险了
     - sql注入: 假设有一个修改操作, 他直接把修改的内容变成一段sql语句, 这时候服务器如果直接去修改的话那段sql语句就会被执行, 就有风险, 所以现在第三方的orm框架都会有防sql注入的操作

33. 常见的http状态码:
     - 200: 代表成功
     - 301： 永久重定向
     - 302: 临时重定向
     - 304: 代表命中缓存, 浏览器可以直接使用缓存的相应数据
     - 400: 客户端的请求出错, 服务器没法识别
     - 401: 身份验证失败
     - 403：拒绝访问
     - 404: 资源未找到
     - 500: 服务器挂了
     - 502: 网关错误

34. http请求头和响应头的字段你都了解哪些？
     - request-headers:
         - cookie
         - method
         - if-modified-since
         - if-none-match
         - Origin: 用户发送该请求的实际源
         - Referer: 用户发送该请求的实际地址
         - Accept: 用户接受的文件类型表
         - Accept-Language: 用户期望的页面语言
         - Accept-Charset: 用户期望的页面编码
         - Authorization: jwt用户鉴权或者一些token
         - user-agent: 用户的终端信息
         - content-type: 文件内容格式
         - Accept-encoding: 允许的压缩方式
         - connection: keep-alive, 过去在http1.0的时候那时候没有长链接这个东西, 都是每一个请求都会重新进行三次握手和四次挥手, 所以开发者使用connection keep-alive来不急着关闭链接, 在http1.1以后长链接成为官方标注了, 就没那么需要这个字段了, 不过为了兼容性浏览器还是会带上
         - 还有的如果你是http2.0的话, 会有很多类似于```:method```, ```:path```之类的以冒号开头的请求头字段, 这个主要是用来压缩头部时用的
     - response-headers:
         - etag:
         - last-modified
         - set-cookie
         - expire:
         - cache-control
         - content-length: 文件内容字节长度
         - content-type
         - Access-Control-Allow-Origin: 跨域相关
         - Access-Control-Allow-Credentials: 跨域是否允许携带cookie配置
         - Content-Security-Policy: csp策略相关, 开启csp策略后浏览器会禁止第三方脚本的加载以及禁止向第三方提交数据以及一些csp的信息上报等
         - Date: 表示消息发送的时间
         - Content-Encoding: 压缩方式

35. 聊聊浏览器的压缩方式
     http压缩是指客户端和服务端使用压缩后的文件内容进行交互, 这样可以减少网络的传输量, 提高用户体验, 采取的方式主要是客户端在request headers请求头中设定Accept-Encoding来表明自己可以接受哪些方式的压缩, 然后服务端收到以后, 选浏览器可以处理的压缩方式去压缩响应给客户端的资源, 并在响应头里设定Content-Encoding字段来表明本次到底使用的是哪种压缩方式, 客户端收到响应以后进行解压, 然后进行正常后续处理, 不过目前前端工程化比如webpack你直接打包他就已经给你压缩了, 貌似在http交互中就没有必要压缩了, 因为压缩主要也是压缩css js资源啥的, 目前我知道的压缩方式有:
     - gzip: 兼容性好, 而且是无损压缩
     - br: 是谷歌新出的一种压缩方式, 然后之前看到过, 不过具体的细节此刻不太记得起来了

36. 强缓存和协商缓存
     - 强缓存: 当响应头里有被挂上expires或者cache-control字段不为no-cache以后, 浏览器会将本次请求的结果缓存下来, 当再次发起该请求时, 浏览器会检查expires字段和cache-control字段的时效性:
         - expires字段: 一个绝对时间, gmt的时间格式, 表示缓存有效期, 超过这个时间则缓存失效, 但是由于时区的一些问题, 这个expires属性可能会有一些意料之外的情况
         - cache-control: 一个相对的时间, max-age=3600, 意思是3600秒的缓存期, 会直接将本地时间加上这个缓存器从而获得一个新的绝对时间
         如果还在时效性内, 则浏览器不会给服务器发送请求, 而是直接使用本地缓存
     - 协商缓存: 如果强缓存没有命中, 且之前服务器有在响应头里设置last-modified或者etag属性的话, 客户端会直接发一次请求来协商决定是否需要重新请求资源, 会带上(if-modified-since或者if-none-match)字段, 服务器会比较这两个字段来告诉浏览器是否可以使用缓存, 如果不需要请求则直接返回304状态码且不会返回资源内容, 此时客户端会直接使用本地缓存, 否则服务器会直接将新的资源内容返回, 并在响应头中放置新的last-modified或者etag字段
         - last-modified: 文件上次修改的时间, 这个有一个缺陷, 就是有时候服务端更新文件并不一定是直接更新了文件内容, 这样的话会造成没有意义的请求
         - etag: 一个客户端和客户端协商好的标记, 一般是hash算法, 因为只要文件内容没有变, 这个hash得到的字符串也不会变化, 这个时候旧可以完美解决last-modified的缺陷了

37. 说说https
     https他相较于http最主要的就是他保证了数据在传输过程中不被窃取和篡改, 他的具体流程和原理是这样的:
     1. 首先我们的操作系统在安装的时候实际上就已经将世界上已知的权威CA机构都留存下来了
     2. 在过去无论是使用对称加密还是非对称加密在首次数据传输过程中都有风险被植入中间人攻击, 导致公钥私钥被窃取然后导致数据被篡改,于是服务器就准备一些钱然后把自己的公钥以及域名啥的信息给到CA机构得到一张证书, 然后在首次交互的时候, 客户端会拿到这张证书
     3. 客户端拿到证书以后会直接验证证书签名, 因为证书签名首先是被CA的私钥加密的, 你使用CA的公钥解密后, 你根据CA的指示去重新计算一遍就可以知道这个证书有没有被伪造和篡改, 如果没有你就拿到服务器的公钥就好了, 这时候你再到你本地生成一个对称加密的私钥用公钥进行包装, 然后服务端收到以后用私钥解密, 以后你们两个就这样交互了, 再也不用担心数据被篡改了
     使用https以后可以极大限度的去避免中间人攻击, 但是有些比较下头的黑客还可能会使用ssl剥离, 再诱导用户 这时候用户就比较难发现了

38. es6有哪些新特性?
     - 新的声明变量的方式let/const
     - 新的数据类型: Symbol
     - 新的函数书写方式: 箭头函数
     - 新的构造函数语法题: class
     - 展开运算符和收集运算符...
     - 字符串数组Object的一些新方法
     - 新的数据结构Map和Set, WeakMap和WeakSet
     - 新的api Proxy, Reflect
     - 迭代器和生成器
     - Promise, async await 
     - 解构

39. 聊聊箭头函数
     箭头函数是es6的一种新的书写函数的方式, 他和原生函数的差异主要表现在这些地方:
     1. 箭头函数没有自己的this, 没有arguments, 没有new.target, 没有原型
     2. 箭头函数的this继承于父级的this, 如果父级也是箭头函数则会依次向上继承
     3. 箭头函数因为没有自己的this和原型所以他是不能被当做构造函数的
     4. 箭头函数是无法用作生成器函数的, 也不能使用yield关键字

40. let var const的区别
     1. var声明的变量允许重复声明, let const不允许
     2. var声明的变量会进行变量提升, let const不会
     3. var申明的变量默认会成为window的属性, 而let const不会, let const声明的变量会被挂载到作用域```[[scope]]```属性里
     4. let和const会直接展开块级作用域, 在某些场景下还会产生暂时性死区
     5. const声明的变量声明就必须显示的赋值 且赋值后不可更改

41. Map和WeakMap有什么不一样的？
     - WeakMap不会影响到垃圾回收, 而Map会, 
     - Map允许任何类型的数据作为key, WeakMap只能使用对象做为key
     - WeakMap是不能被循环和迭代的

42. 如果让你实现一个new你怎么实现的
     1. 在内部使用Object.create来构造一个对象this, create里传递当前构造函数的prototype
     2. 执行他的函数体, this.xxx等于xxx
     3. 最后我得到他函数体的返回值, 如果是一个对象, 我就不返回this, 如果不是一个对象,我直接返回this

43. 说说原型链
     prototype是function对象的一个属性, 他决定了构造函数构造出来的对象的公有祖先, 原型也是对象, 除了Object.create(null)以外每个对象都会有一个__proto__属性指向一个原型, 且最终都会只想Object.prototype, 这种层层链接的形式就叫做原型链, 对象如果在自己身上访问属性没有就会去自己的原型链上找, 日常开发中也有一句话叫做原型链上找不到报undefined, 作用域链上找不到报错

44. 说说call, apply, bind
     call和apply还有bind全部可以改变函数执行环境的this指向, call和apply会直接执行函数, 而bind会返回一个新的已经绑定完毕this的函数, 且被bind绑定过this的函数不可再重新绑定新的this

45. bind如果第一次传入了this我再重新bind一次, 他执行的是哪个this
     第一个, 因为被bind绑定过this的函数不可再重新绑定this

46. Promise之间有哪些状态, 状态之间互相转化
     PromiseA+规范规定 Promise只有3个状态, 一个是pending状态, 一个是fulfilled状态, 一个是rejected状态, 状态始终只能从pending走向fulfilled或者rejected, 且不可逆转, 使状态走向rejected我们需要调用reject方法, 使状态走向fulfilled我们需要调用resolve方法

47. 说说Promise.race, Promise.all
     - Promise.race: 将接受到的可迭代对象的promise集合进行执行, 然后谁最先进入已决的fulfilled状态, 就race进入已决的fulfilled状态, 有一个Promise报错, 则race进入rejected状态
     - Promise.all: 将接受到的可迭代的对象的promise集合进行执行, 所有的promise全部执行完毕并进入已决以后all才会进入已决, 如果有一个没有进入fulfilled, 则all进入rejected

48. 如果Promise.all有一个异常了, 其他Promise还会执行吗？
     肯定会啊, 因为异常这个动作是异步的, 但是5个promise的执行是同步的

49. 如何捕获async和await的异常, 如果不写await promise报错的你的try catch可以捕获到吗?
     使用try catch就可以捕获await 的异常了, 如果不await promise的错误try catch是捕获不到的, 因为Promise始终是要进入微队列的, 而try catch只可以捕获同步的错误, 使用await可以捕获也是因为async await好像是在底层会利用生成器, 然后将代码卡住了, 才可以捕获

50. 说说事件冒泡和事件捕获
     - 事件冒泡: 子元素事件触发后, 事件从子元素依次传播到父级叫做事件冒泡
     - 事件捕获: 子元素事件触发后, 事件从父元素依次传播到子元素叫做事件捕获
     通过addEventListener的第三个参数可以约束是开启冒泡还是捕获, true为捕获false为冒泡, 默认为false, 事件的传播总是先捕获再进行冒泡, 在此期间调用e.stopPropagation可以阻止事件的传播, 利用事件冒泡我们可以做到事件委托, 以达到动态监听dom和节约性能的目的

51. 介绍一下JS的堆和栈, 以及垃圾回收机制
     - 堆: 引用值都会存放在堆, 堆内存的复制实际上是在复制地址, 堆里面的东西用完了必须等到没有任何变量引用到他了才会进行垃圾回收
     - 栈: 原始值都会存放在栈, 栈内存的复制实际上就是在复制副本, 栈内存的东西用完了就直接进行垃圾回收了
     JS的垃圾回收是自动的, 他会周期性的去查看不再继续使用的变量, 释放其内存

52. 说一下css的盒模型
     css的盒子模型可以分为标准盒模型和怪异盒模型
     - 标准盒模型: 该盒子模型的宽度为border + padding + width 
     - 怪异盒子模型: 该盒子模型的宽度就是为width设定的值
     我们可以使用box-sizing去修改单个盒子的显示模式, 同时我记得html5之前是可以通过传递不同的DOCTYPE来变动页面的盒子模型, 利用好不同的盒子模型, 我们可以更加简单的实现一些UI的需求, 比如UI的宽度就是200, 但是我们可以看到他有padding 30, 这个时候我们直接将他转换成怪异盒模型然后照常给width和padding就好了

53. bfc是什么
     bfc: block formatting context, 块级格式化上下文, 是浏览器的一种布局模式, 当一个元素开启了bfc以后, 其内部子元素的布局会单独进入一个上下文, 不会影响到外部元素的布局, 而且bfc 默认情况下html根元素是直接开启bfc的, 然后我们也可以通过一些属性来开启元素的bfc, 比如overflow不为默认值, float, display: flow-root等, 开启了bfc的元素整体呈包裹性, 所以就算是浮动的元素也会被记入高度, 所以我们可以使用开启元素的bfc来清除浮动, 同时bfc也可以处理一些实用性问题, 比如margin塌陷和margin重叠
     - margin重叠: 在同一个bfc元素中的两个元素设置margin-top和margin-bottom, 会发现margin-top和margin-bottom会产生重叠, 会以margin-top和margin-bottom中较高的值作为最终的间距值, 要解决这个问题, 我们可以让其中一个元素单独进入一个独立的bfc容器即可, 即给其中一个元素外层包裹一个div, 并让这个div进入一个新的bfc环境
     - margin塌陷: 当父元素没有设置border, padding, 以及元素内没有任何文字时, 此时设置子元素的margin-top会导致好像是直接设置了父元素的margin-top, 这就是margin塌陷, 我们可以通过开启父元素的bfc来解决这个问题

54. css的定位有哪些
     - static: 默认值, 元素按照文档流常规定位
     - absolute: 绝对定位, 元素脱离文档流, 且设置了absolute以后元素原来的位置将不再占位
     - relative: 相对定位, 元素脱离文档流, 但是元素原来的位置还会继续占位
     - fixed: 固定定位, 元素脱离文档流, 按照document进行定位
     - sticky: 粘性定位, 在未到达粘性定位设置的top, left阈值时, 粘性定位的规则和relative一致, 而到达了设定的阈值以后, 粘性定位和absolute保持一致

55. 有哪些css3属性可以开启gpu加速？
     - opacity
     - transform
     - filter

56. 说一下你现在能想到的前端优化方案
     ok, 那我分几个层面来说: 
     - 构建层面: 
         - 先说开发时, 优化开发时的webpack构建策划可以有效提高我们的开发效率
             - 配置loader的exclude属性来排除不必要的文件转换, 比如node_modules里的文件基本上已经是打包过后的代码了, 我们可以直接排除掉, 避免进行重复loader的计算
             - 使用cache-loader来进行打包内容的缓存, 只要文件内容没有变化, 就不会重新打包这个文件
             - 可以考虑使用thread-loader来开启多线程构建, 但是这个是需要文件数量比较多的场景
         - 然后我们可以来说说生产时态, 生产时态的部分操作对开发时也是有帮助的
             - 开启分包策略, webpack4以前我记得是使用commonChunksPlugin来进行分包策略的, 而webpack4我们使用splitChunks来进行分包策略, 对项目进行分开打包成不同的js, 比如node_modules的目录单独打包成一个js因为大部分情况下这个目录下的文件是不太可能会变得, 单独打包为一个浏览器就方便缓存他们了
             - 开启摇树优化, treeshaking, 目前来说webpack4自动给我们内置了treeshaking, 他可以帮我们清理掉没有用到的东西, 但是webpack4默认只能对es module的文件进行tree shaking, 但是webpack5可以支持commonjs格式的tree shaking, 虽然内置了treeshaking, 但是我们在写代码的时候应该要尽量避免多数功能集成在一个函数里, 会导致treeshaking结果不那么理想
             - 开启cdn优化, 我们可以通过配置webpack的external属性来控制cdn对应的全局变量名, 然后将比较大的第三方库以cdn的形式导入
             - 开启按需加载: 就是使用好webpack提供的import函数来动态引入路由
         - 还有一些是webpack其实已经内置的优化策略, 比如webpack scope hoisting, 这个我也有了解过, 因为开发环境下他是一个模块一个函数, 但是进入生产的时候他会将多个模块合并为一个函数, 但是在里面通过上下文来隔离各个模块之间的冲突, 这种思想我觉得也可以去学学 
     - 说完了构建层面, 我们来说说写代码层面
         - 在操作dom这块我们不必担心, 因为目前来说第三方框架比如vue都帮我们做了虚拟dom和diff算法, 所以对dom的优化 他们已经帮我们做了, 如果我们自己做的话, 其实弄懂虚拟dom和diff算法就基本上是知道怎么做了
         - 然后再css这块
             - 尽量不要写超过3层的css嵌套, 这样会导致css在解析的时候会找的层数很深, 影响查询性能
             - 尽量避免使用通配符选择器啥的
             - 关注继承属性, 避免重复定义样式造成重复匹配和查询
         - 在js脚本这块
             - 尽量利用一些现代化的api如requestAnimationFrame, requestIdleCallback来做一些事情
             - 合理利用好防抖和节流
             - 尽量使用第三方性能好的工具库, 比如lodash, 我之前有测试过lodash.foeach和es官方的foreach, 在海量数据下, lodash的效率会快上三分之一多
     - 然后再说说资源层面的:
         - 在摄取图片资源这类的时候尽量使用webp, 精灵图这类体积小或者一次请求可以用在多个地方的图片
     - 还有就是网络层面:
         - 开启http的缓存, 协商缓存和强缓存看着情况来
         - 开始http压缩, 比如gzip, b, 但是现在webpack也可以在构建时提前压缩, 看怎么来吧 两种方案都可以
     - 最后就是一些目前用到的主流的提升用户体验的手段:
         - 长列表优化
         - 懒加载
         - 预加载
     - 然后我们可以通过performance api来测量性能, 还可以通过webpack的bundle analyzer来分析打包性能, 也可以使用第三方库比如web-vitals来进行性能检测

57. 给两个矩形，有每个矩形点坐标以及长宽高，判断是否相交（包含也算相交
    ```js
    /**
     * 判断两个矩形是否相交: 主要的思路是利用好外包矩形
    * 如果两个矩形的宽加起来大于最小外包矩形的款且两个矩形的高加起来大于最小外包矩形的高, 则判断相交
    * 
    */
    function isIntersect(fstRectangle, secRectangle) {
        const minWrapRectangleWidth = Math.abs(fstRectangle.x - secRectangle.x);
        const minWrapRectangleHeight = Math.abs(fstRectangle.y - secRectangle.y);
        if (fstRectangle.width + secRectangle.with >= minWrapRectangleWidth && fstRectangle.height + secRectangle.height >= minWrapRectangleHeight) {
            return true;
        }
        return false;
    }
    ```

58. vue的响应式数据原理
     vue的响应式数据原理主要是围绕着vue的几个小玩具来进行的:
     - Observer: 这个构造器能够帮助vue给数据打上getter和setter, 他具体的方式是深度递归data数据, 然后给每一个数据使用Object.defineProperty进行getter和setter的绑定, 有了getter和setter以后, vue就有机会在读取属性和修改属性的时候做一些事情, 但是Object.defineProperty是有一些缺陷的, 一个是他没法监听对象成员的新增和删除, 所以vue2单独追加了$set, $delete方法, 另一个就是性能不太好, 因为vue2是递归深度遍历, 当数据比较复杂的时候可想而知要代理多少个数据, 就和我们给1000个dom节点绑定事件会消耗性能一样, 他给复杂数据进行代理也会出现一些性能问题, 不过vue2没办法。 在vue3中, Vue将Object.defineProperty替换成了Proxy, Proxy对于对象的代理是动态的, 就和事件委托一样, 所以这两个缺陷都得到了比较好的解决, 我也是有看到vue3将$set,$delete方法都移除了
     - Dep: 上面我们说到, Observer可以帮我们给数据打上getter和setter, 但是具体的getter和setter里做了什么, Observer会交给其他人去做, 首先在getter中, Dep会调用Dep.depends方法来收集依赖, 因为你读取了这个属性就证明你这个上下文依赖这个属性, 而在setter中, Dep会调用notify方法去通知依赖项数据变动了, 你需要重新计算, 所以每个响应式数据其实都会对应一个Dep的
     - Watcher: 虽然Dep可以收集依赖, 但是他是真的不知道该收集谁作为依赖, 实际上我上面也说了, 你的上下文其实就是依赖该数据的人, 所以在Dep的收集依赖的过程中, 他主要收集的是Watcher, Watcher是每个组件实例上都会对应的一个对象, Watcher中保存了副作用方法比如render, 当我们通知依赖项时其实通知的也是Watcher, 由Watcher去决定是重新调用render 还是watchEffect? 
     - Schedular, 调度区, 我们说到Watcher他其实已经是可以做到变更了, 但是这时候还有一个问题, 比如我们在某一刻更改了三次数据, 那么页面需要刷新3次吗？ 其实可能只需要最后一次的变更就行了, 所以Watcher在被通知时会把自己交给Schedular, 调度器最终会调用nextTick将其推入微队列进行合并执行, 这就是整个数据响应式的过程

59. animation和transition的区别
     animation是动画, transition是过渡, 如果非要说的话transition是只有2个帧的动画（0, 100）, 而animation可以非常精细的控制每一小帧, transition是由属性的变化而触发的, animation实际上我们可以更加精准的控制

60. Vue组件通信
     - 父子组件传值 直接props就可以了
     - 如果是兄弟组件的话可以尝试使用 emit event, 即一边注册一个事件, 另一边去使用$emit去触发这个事件并传值
     - 过去还有个event bus, 原理是单独开一个Vue实例出来进行共享, 不过具体的我忘了
     - vue3就比较方便了, vue3得益于reactivity api的暴露出来, 使得我们不用在组件上下文里也可以创建响应式数据, 所以我们完全可以做到和react hooks一样的 定义自定义hook来进行数据通信
     - 如果还有比较复杂的场景的话 那可能只能使用vuex这类数据仓库了

61. 前端模块化的优势
     - 避免变量污染, 命名冲突
     - 提高可维护性和复用性

62. koa中间件洋葱模型(后补)

63. Promise的错误处理, async await的错误处理
     Promise的错误处理可以直接使用catch去捕捉, 也可以使用then的第2个参数去捕获, async await的话一样可以使用Promise的处理模式, 还可以给await的地方打上try catch来捕捉错误, 注意finally并不能拦截错误

64. 两数之和
    ```js
    function twoSum(nums = [], sum) {
        if (!Array.isArray(nums) || typeof sum !== "number") return [];
        const map = new Map([]);
        const result = [];
        for (let i = 0; i < nums.length; i++) {
            for (let j = i + 1; j < nums.length; j++) {
                if (nums[j] + nums[i] === sum) {
                    result.push([i, j]);
                }
            }
        }
        return result;
    }
    ```

65. 给一个数n, 然后生成一个0-n的乱序数组(后补: 提示使用Math.random + sort)
    ```js
    function getRandomArr(number) {
        const result = [];
        for (let i = 0; i <= number; i ++) {
            result.push(i);
        }
        result.sort(() => Math.random() > 0.5 ? -1 : 1);
        return result;
    }
    ```

66. 三数之和
    ```js
    function threeNum(nums = [], target) {
        if (!Array.isArray(nums) || typeof target !== "number") return [];
        const result = [];
        for (let x = 0; x < nums.length; x++) {
            for (let y = x + 1; y < nums.length; y++) {
                for (let z = y + 1; z < nums.length; z++) {
                    if (nums[x] + nums[y] + nums[z] === target) {
                        const matchValue = [nums[x], nums[y], nums[z]].sort((a, b) => a - b);
                        const isExist = result.find((value) => {
                            return JSON.stringify(value) === JSON.stringify(matchValue);
                        })
                        !isExist && result.push(matchValue);
                    }
                }
            }
        }
        return result;
    }

    ```

67. 跨域和解决方案  
     浏览器有个同源策略, 也就是只能允许同域名同协议同端口的客户端和服务端才能进行通信, 否则将会被拦截, 要避开这个限制我们可以使用如下的方案:
     - jsonp, 一种比较古老的跨域手段, 主要是利用了script标签的src属性不受同源策略影响的原理
     - cors, 这个需要服务器在响应头里设置Access-Control-Allow-Origin字段来控制允许跨域的域,. 这样浏览器在发现有这个字段并且检查匹配过后就会放行, 同时搭配这个字段还有一些其他的字段比如Access-Control-Allow-Credentials意为是否允许跨域的时候携带cookie
     - location + iframe, document.domain+iframe跨域 这个以前了解过, 现在不太记得了
     - 如果是在开发环境, 可以使用webpack的devServer进行跨域, 这个的主要原理是webpack会利用koa单开一个本地服务器, 用本地服务器去请求数据然后再传回客户端

68. 谈谈你对虚拟dom的理解
     虚拟dom本质上就是一个js对象, 他主要是用来描述页面结构的, 因为我们在框架使用时, 可能会频繁的导致render函数被重新调用, 这就导致也一个结果, render函数可能需要频繁的更新页面, 如果我们每次都用真实dom, 那就会频繁的创建和更新真实dom, 这是极其耗费性能的, 就拿创建来说, 我之前做过一个测试, 创建一百万个真实dom对象和创建一百万个普通JS对象耗时相差非常大, 而利用虚拟dom则可可以帮我们将多次对真实dom的操作意图 转换到对象的频繁变动上去, 最终再一次性的变动到真实dom上, 这就避免了很多不必要的更新, 也会节约不少性能, 基于这一点, 虚拟dom我们可以想怎么处理就怎么处理, 而完全不用过分的去担心性能问题, 所以在vue里他的patch算法中就会去尝试重用真实dom, 不停的移动真实dom到各个虚拟dom的引用中, 这件事如果发生在真实dom上, 是不敢想象的, 同理React也是如此, 在render时总是会尝试去重用虚拟dom所对应的真实节点, 在尝试的过程中我们不用去读取真实dom的任何属性, 而是直接使用虚拟dom的属性进行比较, 会比较方便而且性能更好。在我看来虚拟dom更像是一个代理, 他代理了绝大多数本该直接在真实dom上的更改, 当界面产生变更dom的诉求和行为时, 虚拟dom可以在更新真实dom前去做一些事情(比如合并更新, 复用真实dom)等

69. 请谈谈http协议的三个版本1.0 1.1 2.0

     - http1.0: 他最大的特点好像是无法复用连接, 就是他每一次资源的请求都会重新进行三次握手和四次挥手, 每一次都是基于一个新的tcp连接的，同时他有个队头阻塞的问题, 队头阻塞的意思就是上一个请求没有到来之前, 下一个请求别想着发出去, 关于无法复用连接这个问题, 当时社区是有个大家一起遵守的规范就是给请求头里追加connection: keep-alive来保证连接长久的存在
     - http1.1: 他最大的特点就是开启了长连接时代, 就是他可以复用tcp连接了, 就是当一次tcp连接建立以后, 服务器和客户端都不会急着挂电话, 会有一个心跳检测的过程, 如果非要挂电话客户端可以挂, 服务器也可以主动挂, 如果电话没挂, 则一直复用这个tcp连接, 另一个特点就是http1.1尝试解决http1.0的那个队头阻塞的问题, 好像搞了个什么管道, 就是上一次请求没回来他直接发下一次请求的, 但是那个好像会有些问题
     - http2.0: http2.0主要是使用一个手段好像叫做二进制分帧来解决了队头阻塞的问题(这个我不太记得具体的细节了), 所以http2.0说是可以多路复用, 另外http2.0会压缩头部, 具体的原理就是一些比较通用的请求头和响应头字段, 客户端还有服务器都会保存一个静态表, 比如数字1代表的就是method: POST, 然后每次传输就直接传个1就可以了, 然后还有一个动态表比如cookie, cookie就是首次会明文发给服务器端, 但是本地会生成一个数字来映射这个cookie, 然后以后都会用这个数字来进行通信了, 好像是这样, 所以不是现在很多使用http2.0的请求消息头里都有什么```:method```这样的玩意, 以冒号开头的多数都是静态表和动态表里的东西, 用来压缩头部的

70. 为什么http1.1不能实现多路复用？

     http1.1的传输单元是整个响应文本, 因此接收方必须接受完所有内容以后才能接受下一个传输单元, 否则就会造成混乱, 而http2.0的传输单元更小, 是一个二进制帧, 然后每一个二进制帧都有属于自己编号, 表示属于哪个响应文本, 所以即便是不同的响应文本交替传输. http2.0也可以分的很清楚, 基于这一点自然就可以实现多路复用了

71. 简单讲解一下http2.0的多路复用？

     在http2.0中, 有两个比较重要的概念, 叫做帧和流, 帧代表着最小的数据单位, 流就是具体的响应报文, 每个帧都有一个编号标识出自己属于哪个流, 多路复用的意思就是在一个tcp连接中, 可以存在多条流, 换句话说就是可以同时处理多个请求, 通过将流拆分成帧来源源不断的处理不同请求, 在客户端则可以根据编号来区分每一帧属于哪个流, 从而提高传输性能, 这就是多路复用

72. http1.1是怎么复用tcp连接的？

     客户端请求服务器时, 通过请求行告诉服务器使用的协议是http1.1, 同时在请求头中附带connection为keep-alive(主要是为了兼容http1.0), 告诉服务器这是一个长连接, 后续请求可以重复的使用这次tcp连接

     这样做的好处就是为了减少三次挥手和四次握手的次数, 一定程度上提升了网络利用率, 但由于http1.1不支持多路复用, 所以我记得实际项目中都会开多个域名来传输静态资源以达到建立多次tcp连接的目的？

73. ssl, tls, https之间的关系有了解过吗
    - ssl: secure socket layer 安全套接字协议
    - tls: transport layer security 传输层安全协议
    tsl是ssl的升级版, 两者几乎是一样的
    - https: hyper text transfer protocol over secure socket layer 建立在ssl上的http协议 而http是直接建立在tcp上的协议

74. https的数字证书是干嘛的
    数字证书一般包含下面几个东西:
    - 服务器的域名
    - 服务器的公钥
    - 用CA私钥加密过的证书签名
    这证书签名用CA私钥加密的东西只能使用CA公钥(CA公钥反正全世界都知道)解密, 而且不能被伪造, 因为他没有CA的私钥, 黑客也可以解密, 但是他不能伪造
    - 证书签名做的事情是来做双保险的, 他是用来防止证书被篡改的, 因为黑客虽然不能改证书签名, 他直接改域名和机构倒是可以的 不过证书签名又把他卡死了 证书签名组成如下:
        - 服务器域名+CA公钥+服务器公钥
        证书签名的算法是公开的, 就是通过这三个东西加上一定的算法得到结果, 这时候客户端就可以根据自己的公钥+已知的CA公钥+服务器域名去重新计算一下, 看看有没有信息被篡改, 挨个再检查一次, 这时候通过了就是真的通过了, 如果通不过就代表被篡改了

75. mac地址和ip地址的区别是什么？
    mac地址是不和网络相关的, 标识的是类似于身份证一样的全球唯一编号, 而ip地址表述的是你当前所在的网络环境, mac地址是不能变动的, 而ip地址是会根据你所在的网络环境进行变动的

76. 说说五层网络模型
    从上到下分别为: 应用层, 传输层, 网络层, 数据链路层, 物理层, 当消息发送, 从上到下进行加包封装, 当消息收到时, 从下到上进行解包, 具体每个层所做的事情大概如下:
    - 应用层: 决定了消息具体使用的消息格式, 比如http, ftp等
    - 传输层: 决定了消息具体使用的传输方式, 比如tcp, udp
    - 网络层: 决定了如何在网络中找到对方位置, ip 路由器都在这一层
    - 数据链路层: 决定了如何在一个子网中找到精确的位置, mac地址
    - 物理层: 将二进制转换为信号利用介质比如光纤发送出去


77. 当浏览器敲下一个url到页面展示都做了什么？
    1. 浏览器会自动补全你输入的url的端口和协议
    2. 浏览器会完成url编码, 比如你在url里输入的中文什么的会被强制编码为ASCII码字符
    3. 浏览器会根据url地址去查找本地缓存, 检查规则查看是否命中了缓存 如果命中了缓存, 则直接使用缓存, 后续流程终止
    4. 如果没有命中缓存, 则会进行dns域名解析, 首先会先到本地的host文件中找有没有记录这个域名对应的ip, 如果没有的话就去最近的dns服务器找
    5. 通过dns解析得到服务器ip, 然后向服务器ip发送tcp连接申请, 然后和服务器完成三次握手以后建立连接, 如果使用的是http协议, 还会走一些额外的事情比如开启加密通道, 验证证书之类的
    6. 浏览器此时会决定携带哪些cookie进入请求头中(只有满足同域名, 不需要同端口, 并且cookie的path匹配上, 同时还要检查cookie的secure属性)
    7. 浏览器发送请求, 服务器处理请求, 服务器会根据自己的业务逻辑响应http报文给到客户端
    8. 在这个阶段, 其实服务器和客户端都会做一件事情, 就是根据http版本号以及connection字段去决定是否需要留存本次tcp链接通道
    9. 浏览器会根据响应结果去做一些后续处理, 比如如果是html文档就解析html文档, 还有就是cookie 缓存等一些必要信息的更新
    10. 浏览器解析html的话会依次创建dom树, cssom树, 以及合成渲染树 然后进行布局, 最终通过gpu渲染到页面上, 并触发一些dom的事件, 然后用户看到界面
    然后这个中间又涉及到一个五层网络模型, 但是这个我研究的不是很深, 可以粗略的讲一下:
    - 首先是应用层: 应用层决定了用本次消息发送的消息格式, 上面肯定是http
    - 其次是进入传输层: 敲下url大多数情况下应该都是选择tcp协议进行传输
    - 然后就是网络层: 网络层决定了服务端和客户端进行互相定位的根本, 比如通过ip路由器
    - 然后就是数据链路层: 数据链路层决定了当定位到一个子网以后, 具体怎么分发给实际的客户端, 可以通过mac地址
    - 最后就是物理层: 物理层他会将二进制数据转换为信号通过光纤最终将消息发送给指定终端 

78. 一个字节等于多少位？
    8位, 1kb = 1024字节

79. 请简述TCP连接的过程:
    TCP经过三次握手建立点到点的可靠连接:
    - 第一次握手: 类似于客户端问服务器 你能听到吗？ 具体流程是, 客户端发送一个sync包到服务器, 并进入syn_sent状态, 这个状态表示客户端已经发送了第一次握手消息, 等服务器回应中, 在发送的包中还有一些信息比如seq, 不过我忘记seq是干嘛的了
    - 第二次握手: 发生在服务器收到消息以后, 他回复客户端说: 我听到了, 你呢？ 你还在吗？ 具体流程是客户端接受到sync包以后给客户端发送一个ack包, 并进入一个estab_lished状态
    - 第三次握手: 发生在客户端收到消息以后, 客户端再次回复客户端说我还在呢 我们开始通信把, 具体流程就是客户端也受到了服务端发送来的ack包, 也进入estab_lished状态

80. 谈谈你对三次握手和四次挥手的理解
    - 第一次挥手: 当客户端发完消息以后他会直接给服务器说“我说完了, 挂了吧？”, 具体的流程就是客户端会发送一个FIN包给服务端, 并进入FIN-WAIT阶段等待服务器响应, 当进入FIN_WAIT阶段以后客户端将不再主动给服务器发送信息
    - 第二次挥手: 这时候服务器也收到了客户端的挂断请求, 但是服务端这时候还不打算挂, 因为他还打算回复客户端的消息呢, 他就说“我知道你说完了, 你先别挂, 我还没说呢”, 具体流程就是服务端继续发送ACK包以及数据过去, 因为客户端没有收到FIN包, 所以不会挂电话, 并等着服务器继续发
    - 第三次挥手: 这时候服务器也说完了, 他就说“我也说完了, 咱们挂把”, 具体流程就是服务端会主动发送一个FIN包过去表示自己这边也打算挂了
    - 第四次挥手: 客户端发现服务器也完了就说“好的收到”, 具体流程就是客户端发送一个ACK包确认信息并进入等待关闭状态(进入等待状态主要是因为怕这个ACK包确认信息丢包了, 丢包了服务器就收不到啊, 那服务器就会继续发确认包过来, 这时候如果客户端直接关闭那就收不到这个确认包了), 然后服务器收到信息以后断开链接 客户端也断开链接, 双方销毁对应的内存空间

81. 请谈谈http和tcp的关系
    - http是属于应用层的: 他规定了响应头响应体等消息格式
    - tcp是属于传输层的: 他实现了http消息的可靠传输
    - 使用http协议建立的tcp链接 只能允许客户端主动发消息给服务器, 而不允许服务器主动发消息给客户端

82. 写出几种排序(快速排序, 冒泡排序, 选择排序)(后补)

83. 买卖股票最佳时机(leecode 122)(后补)
    ```js
    function maxProfit(prices = []) {
        if (!Array.isArray(prices)) return 0;
        //     [7,1,5,3,6,4]
        // 输出：5
        let minIndex = 0;
        for (let i = 1; i < prices.length; i++) {
            if (prices[i] < prices[minIndex]) minIndex = i;
        }

        let maxIndex = minIndex;
        for (let i = maxIndex + 1; i < prices.length; i++) {
            if (prices[i] > prices[maxIndex]) maxIndex = i;
        }

        if (minIndex === maxIndex) return 0;
        return prices[maxIndex] - prices[minIndex];
    }
    ```

84. 能说说React Fiber吗？
    React Fiber就是React的虚拟dom, 每个Fiber保存了组件的信息, dom等信息, 举个例子, 当首次渲染时, React会直接创建整个React架构的根节点: FiberRootNode, 然后会依次调用不同的组件的render, 产生不同的RootFiber, FiberRootNode只有一个, RootFiber可以有多个, 比如函数组件会创建一个Fiber节点, 这个Fiber节点的类型叫做Function Component, 然后我们用JSX写出的每个标签都会生成一个Fiber, Fiber的类型叫做HostComponent, 还有很多其他的节点类型, 这些节点相互连接, 就生成了Fiber树, 但是这里要记得, 当面对同级的Fiber节点时, React使用sibling来指向兄弟节点, 所以一个节点只会和一个子Fiber节点连接, 剩下的靠这个子Fiber节点的sibling属性进行连接, 然后每个Fiber的return会指向自身的父级节点, 同时Fiber保存了组件更新的状态以及需要执行的副作用, 比如需要删除的Fiber会打上Delete标记, 最终会在commit阶段根据这些标记进行对应真实dom的更新, 同时React16推出了一种基于Fiber的架构叫做双缓存架构, 我们上面说的是每个React应用都会有一个FiberRootNode, 这个FiberRootNode会有一个current属性指向当前的fiber树也就是RootFiber根节点, current指向的是页面中实际渲染的currentFiber树, 而每次更新都会根据currenFiber + JSX Element 对象 构建一颗新的WorkInProgressFiberTree, 在构建过程中会无限尝试复用旧树的属性和节点(这个过程实际上就是diff算法) , 当workInProgressFiber构建完毕以后会进入commit阶段, 进入commit阶段并修改真实dom以后, fiberRootNode的current树会变更为workInProgressFiber, 他始终采取一种在内存中将新树构建好, 然后最终进入commit阶段一次性修改页面,而Vue其实是遇到了什么就改什么, 边diff边更改, 当遇到计算量比较大的时候 容易卡帧, 这就是双缓存模型, 这也是我对ReactFiber的理解, 可能会有点问题, 因为这个还是之前在React Conf大会上听一些大佬说了以后, 然后自己去找资料慢慢理解的。


85. 可以说说react 渲染流程吗？
    首先无论是在挂载还是更新阶段, React都将整个渲染流程分为两个阶段一个是render阶段, 一个是commit阶段, 在render阶段时, React会从构建一颗workInProgressFiberTree出来, 在commit阶段React会真正的去根据这棵树去修改对应的真实dom, React区分这两个阶段的主要目的是实现可中断渲染, 也就是在render阶段, React当遇到更高优先级的任务时可以暂停render的工作而是砖头去处理更高优先级的任务, 他利用reconciler这个包实现了一个requestIdleCallback, 将复杂的任务进行了时间切片, 利用好了浏览器每一帧所空闲的时间, 会提高不少的用户体验, 同时还有一个点, 就是无论是在挂载阶段还是在更新阶段, React组件都会从performUnitOfWork这个函数开始, 但是因为在挂载阶段没有currentFiberTree, 所以会有一些小区别 这是前言, 那么我接下来来说一下React在挂载和更新阶段的一些大致流程:
    在挂载阶段, React在performUnitOfWork这个入口中会根据不同的React元素类型去构建出不同的fiber节点, 然后根据不同的fiber节点去做不同的事情, 比如如果是函数节点就会去调用renderWithHooks方法去得到子元素并递归生成fiber节点, 然后如果是类组件节点就会实例化类并按规则去调用类的生命周期, 通过render得到子元素并递归生成fiber节点, 然后会和自己的fiber子节点进行一些连接, 他只会连接自己的第一个子节点, 然后其余子节点由第一个子节点的sibling属性去连接, React在这个阶段中保持深度优先的原则, 当这个阶段完成以后整颗虚拟dom树也就完成了, 当然在这个阶段中, 任何具有更高优先级的任务都将打断渲染, 并去处理更高优先级的任务, 当虚拟dom树构建完毕以后, 也会去触发一些声明周期方法和callhooks, 这些在各个阶段都会有触发的, 具体什么时候触发就是看生命周期的触发规则就知道了, 然后workInProgress树已经构建好了, React会直接将其丢入commit阶段, commit阶段的工作将不能被中断, React会在这个阶段将fiber树映射成真实dom树, 同时会将fiberRootNode的current指向这颗fiber树 于是挂载阶段就走完了
    在更新阶段, 走的流程也大致差不多, 都会从render阶段走向commit阶段, 但是在更新阶段, current树是已经存在的, 所以React在diff的时候会想尽办法去复用dom, React在更新的时候会做一些假设:
    1. 节点不会进行层级的移动
    2. 节点如果tag类型产生了变化, 则子节点全部销毁进行重新构建
    3. 可以通过key值来约束节点的一个稳定性
    基于这三个假设, React会依次拿current树去比较ReactCreateElement所生成的对象, 然后如果对比时两个节点的type值和key是一致的, 则直接重用dom, 如果key值不同type值相同也是不会重用的, 如果重用的话, 会检查哪些属性会发生变更, 然后给需要给对应的fiber节点打上更新的标记, 已等到commit阶段一起更新, 如果不一致则直接给之前的fiber节点打上delete的标记, 同时给新节点打上插入的标记, 然后再这个过程中, 如果涉及到组件节点, 又会去调用他们的生命周期方法啥的

86. 算法 大数相乘

87. 算法 括号生成

88. 算法 链表反转
    ```js
    function reverseLink(root) {
        let baseRoot = node = JSON.parse(JSON.stringify(root));
        if (node.next = null) return node;
        while(node.next.next != null) {
            node = node.next;
        }
        const lastNode = node.next;
        node.next = null;
        lastNode = reverseLink(baseRoot);
        return lastNode;
    }
    ```

89. 求连续子数组的最大和
    ```js

    ```

90. 说说你知道的设计模式:

- 单例模式: 保证一个类仅有一个实例, 并提供一个访问他的全局访问点, 比如我之前写那个socket的时候, 外界一般会调用一个socket类上的一个静态方法getSocketInstance(做这个主要是为了方便我们做埋点, 知道哪些地方用到了socket实例)得到一个socket实例, 然后我会在类里面保存一个私有属性, 当首次获得实例的时候, 会直接在内部new 一个socket实例, 而后续则会直接复用这个socket实例了并不会重新new了, 这就是单例模式, 然后比如还有的就是弹窗, 我们没必要每次弹窗都创建不同的弹窗, 我们只需要在全局挂载一个弹窗组件, 当需要显示的时候展示这个组件就好了,不需要的试试display: none掉
- 策略模式: 定义一系列的算法, 将他们一个一个的封装起来, 并且使他们可以相互替换
- 代理模式: 为一个对象提供一个中间层, 来控制对他的访问, 比如vue的数据响应式
- 发布订阅模式(观察者模式): 比如EventEmitter
- 装饰者模式: 比如hof
然后还有一些比如职责链模式, 命令模式, 享元模式什么的, 平时没怎么用, 所以就不太记得了, 但是以前都看过

91. 说说React的事件

React在17以前是在document注册事件的, 在17以后是给react容器也就是#root绑定事件的, 所有的元素点击事件都会冒泡到document或者容器dom上, 在document的事件处理中, react会根据虚拟dom树的结构完成事件函数的调用, 然后如果我们在原生dom上进行了阻止冒泡操作, 那react的事件会直接失效, 同时react事件中的事件源对象并非真实的事件参数e, 而是react合成的一个事件源对象, 比如e.stopPropagation他阻止的不是真实dom的事件冒泡, 而是他自己的虚拟dom的冒泡, 同时react会有一个复用事件对象的操作, 他会在一段时间以后重用这个事件对象, 只是修改属性值, 如果我们希望重用事件, 需要调用e.persist

92. stopPropagation和stopImmediatePropagation的区别？

stopPropagation只会停止当前事件注册函数的一个冒泡, 而Immediate是直接将同类型的事件全部拜拜了

93. 字符串比较原理有了解过吗？
    从两个字符串的第一个字符开始逐个比较, 主要是比较每一个字符对应的ASCII码的值, 如果出现不同的值或者比完就结束了。

94. UDP怎么实现可靠传输?
    如果要看udp怎么实现可靠传输, 我们可以直接看tcp相较于udp多做了什么
    1. 多了seq/ack的包, 以及未收到响应重复发包的机制, 添加发送和接包缓冲区等待响应
    我记得是有个udt协议？ 具体的可能不太了解了

95. 说说href和src的区别？
    src加载的时候会暂停其他任务的进行, 比如html文档的解析, 所以我们会尽量将script标签放到最底部或者追加defer或者async标记
    href加载的时候不会阻碍其他任务比如html文档解析的执行, 在另一些场景下href更像是定义当前节点和目标资源的联系, 比如a标签的对应地址, 而src就是会直接将资源放入到当前节点中

96. 浏览器每一帧都做什么？
    1. 接受输入事件
    2. 执行事件回调
    3. 执行requestAnimationFrame
    4. 页面布局, 样式计算
    5. 绘制渲染
    6. 执行requestIdleCallback